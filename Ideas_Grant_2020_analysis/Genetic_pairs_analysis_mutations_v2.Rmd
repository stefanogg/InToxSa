---
title: "VANANZ closely related pairs: mutations version 2"
author: "Stefano Giulieri"
date: "08/05/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Set/check knitR option and working directory

```{r setup, include=T, message=F}
library(tidyverse)
library(ggpubr)
library(harrietr)
library(here)
library(ggtree)
library(phytools)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here())
print(paste("My working directory is:" ,here()))
rm(list = ls())
```

# Import and process snippy data

## Snippy output

```{r message=F, warning=F}
snippy_data <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/all_pair_id_snps.mask.tab") %>%
  arrange(PAIR_ID)
snippy_data 

# modify snippy output: 
# 1) generate iso1 and iso2 for merging with the phenotypic analysis
# 2) modify CHROM (contig name) to be consistent with the labelling in bed files down the track
# 3) extract mutation effects for easier interpretation


source("../Functions/aa_convert.R")
snippy_data_modified <- snippy_data %>%
  mutate(iso1 = str_remove(REFERENCE, ".gbk"),
         iso2 = ISOLATE,
         CHROM = str_c(iso1, "_", CHROM)) %>%
  separate(EFFECT, 
           into = c("EFFTYPE", "NUCLEOTIDE_CHANGE", "MUTATION"), 
           sep = "\\s", 
           remove = T, 
           extra = "merge") %>%
  mutate(NUCLEOTIDE_CHANGE = str_remove(NUCLEOTIDE_CHANGE, "c."),
         MUTATION = str_remove(MUTATION, "p."),
         MUTATION_SHORT = aa_convert(MUTATION)) %>%
  separate(AA_POS, 
           into = c("AA_POS", "AA_LENGTH"), 
           sep = "/", 
           remove = T) %>%
  mutate_at(vars(starts_with("AA")), 
            as.numeric)
snippy_data_modified

snippy_data_modified %>%
  .$ISOLATE %>%
  n_distinct()
rm(snippy_data, aa_convert)
```

## Inspect number of mutations

Based on the SNP matrix we expect a low number of mutations. However, the density plot shows that a small proportion of pairs have hundreds of mutations. We remove pairs with > 100 mutations.

```{r}
df_n_mutations <- snippy_data_modified %>%
  count(PAIR_ID, sort = T)
df_n_mutations %>%
  ggplot(aes(x = n)) +
  # geom_histogram() +
  geom_density(fill = "red") +
  labs(x = "Number of mutations") +
  theme_bw()

# ggsave("Ideas_Grant_2020_analysis/figures/mutations_density.pdf", width = 4, height = 2.5)

distant_pairs <- df_n_mutations %>%
  filter(n > 100) %>%
  .$PAIR_ID
snippy_data_modified_no_distant_pairs <- snippy_data_modified %>%
  filter(!PAIR_ID %in% distant_pairs)

n_distinct(snippy_data_modified_no_distant_pairs$ISOLATE)

rm(distant_pairs, df_n_mutations, snippy_data_modified)
```


## clustering of protein genes (cd-hit)

```{r message=F, warning=F}
protein_clusters_data <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/mutated_proteins.cd-hit.tab") %>%
  rename_all(funs(str_c(., "_prot"))) 

nebraska_clusters <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/representative_proteins_FPR3757_cd-hit.tab") %>%
  mutate(source = if_else(str_detect(id, "SAUSA300"), "FPR3757", "mutated_proteins")) %>%
  group_by(clstr) %>%
  filter(any(str_detect(id, "BPH"))) %>%
  group_by(clstr, source) %>%
  arrange(desc(clstr_cov, clstr_id)) %>%
  filter(!(source == "FPR3757" & row_number() > 1)) %>%
  mutate(source_long = str_c(source, "_", row_number())) %>%
  ungroup() %>%
  select(id, clstr, source_long) %>%
  pivot_wider(names_from = source_long, values_from = id) %>%
  pivot_longer(cols = starts_with("mutated_proteins"), names_to = "source_long", values_to = "id_prot") %>%
  drop_na(id_prot) %>%
  select(id_prot, nebraska_locus_tag = FPR3757_1) 

df_neb <- read_csv("Ideas_Grant_2020_analysis/Raw_data/nebraska_all_proteins.csv") %>%
  rename(neb_mutant_id = `Strain Name`, neb_gene = `Gene name`, neb_product = `gene discription`) %>%
  filter(neb_mutant_id != "NE290") #fix issue with double entry for SAUSA300_0721

protein_clusters_data <- protein_clusters_data %>%
  left_join(nebraska_clusters) %>%
  group_by(clstr_prot) %>%
  mutate(nebraska_locus_tag = nebraska_locus_tag[which(clstr_rep_prot == 1)]) %>%
  left_join(df_neb)



protein_seq_data <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/mutated_proteins.tab") %>%
  rename_all(funs(str_c(., "_prot")))
```

## merge clusters and sequences with snippy data

```{r}
snippy_data_modified_proteins <- snippy_data_modified_no_distant_pairs %>%
  left_join(protein_clusters_data,
            by = c("LOCUS_TAG" = "id_prot")) %>%
  left_join(protein_seq_data,
            by = c("LOCUS_TAG" = "FASTA_ID_prot"))
snippy_data_modified_proteins
rm(df_neb, protein_clusters_data, protein_seq_data, nebraska_clusters, snippy_data_modified_no_distant_pairs)
```

## clustering and annotation of intergenic regions 

### gff with annotation of intergenic regions

```{r}
col_names <- c("CHROM_intergenic", 
               "START", 
               "END", 
               "CHROM_protein", 
               "SOURCE", 
               "TYPE", 
               "START_flank_prot", 
               "END_flank_prot", 
               "SCORE", 
               "STRAND_flank_prot", 
               "PHASE", 
               "ATTRIBUTES_flank_prot",  
               "CHROM_mutation",
               "POS_minus1",
               "POS", 
               "PAIR_ID", 
               "REFERENCE", 
               "ISOLATE")

intergenic_regions_annotated <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/all_mutated.intergenic.annotated.bed",
                                         col_names = col_names) %>%
  select(CHROM = CHROM_intergenic, 
         START, 
         END, 
         START_flank_prot, 
         END_flank_prot, 
         STRAND_flank_prot, 
         ATTRIBUTES_flank_prot, 
         POS, 
         PAIR_ID, 
         REFERENCE, 
         ISOLATE) 
upstream_proteins <- intergenic_regions_annotated %>%
  group_by(CHROM, START, END, POS, PAIR_ID, REFERENCE, ISOLATE) %>%
  filter(END_flank_prot < POS) %>%
  rename_at(vars(ends_with("_flank_prot")),
            funs(str_c(., "_upstream")))
downstream_proteins <- intergenic_regions_annotated %>%
  group_by(CHROM, START, END, POS, PAIR_ID, REFERENCE, ISOLATE) %>%
  filter(START_flank_prot > POS) %>%
  rename_at(vars(ends_with("_flank_prot")),
            funs(str_c(., "_downstream")))
intergenic_regions_annotated <- upstream_proteins %>%
  left_join(downstream_proteins)
intergenic_regions_annotated

rm(upstream_proteins, downstream_proteins, col_names)
```

### cd-hit clustering of intergenic regions

```{r}
intergenic_clusters_data <- read_tsv("Ideas_Grant_2020_analysis/Raw_data/all_mutated.intergenic.cd-hit.tab") %>%
  separate(id, into = c("CHROM", "START", "END"), sep = "[:-]", remove = F) %>%
  rename_at(vars(id, starts_with("clstr")),
            funs(str_c(., "_intergenic"))) %>%
  mutate_at(vars(START, END), as.numeric) %>%
  distinct()

snippy_data_modified_proteins_intergenic_regions <- snippy_data_modified_proteins %>%
  left_join(intergenic_regions_annotated,
            by = c("CHROM", "POS", "PAIR_ID", "REFERENCE", "ISOLATE")) %>%
  left_join(intergenic_clusters_data)

rm(intergenic_regions_annotated, intergenic_clusters_data)
```

# Create datasets of contrasting clinical outcomes 

## Pairs with contrasting patient mortality (survived-died switches)

### Import Romain's dataset

A dataset with all genetic pairs with mortality data **and** phenotypic data

```{r message=F}
df_phenotypes <- read_csv("Ideas_Grant_2020_analysis/Genetic_pairs_table/genetic_pairs_pheno_changes_mortality_switches.csv")

# check available phenotypes
# mortality
df_phenotypes %>%
  select(iso1, iso2, switches) %>%
  distinct() %>%
  count(switches)
```

### most mortality phenotypes are not available. Need to recalculate that

We need to import the dataset with all genetic pairs annoated with mortality data. Phenotypic data will be `NA` for most of the pairs, but that's ok.

```{r}
df_all_genetic_pairs_pheno <- read_csv("Ideas_Grant_2020_analysis/Genetic_pairs_table/df_all_genetic_pairs_pheno.csv")


df_all_genetic_pairs_pheno %>%
  select(iso1, iso2, iso1_mortality, iso2_mortality) %>%
  filter(is.na(iso1_mortality) | is.na(iso2_mortality))

df_all_genetic_pairs_pheno_mortality_switches <- df_all_genetic_pairs_pheno %>%
  mutate(switches = str_c(iso1_mortality, "-", iso2_mortality))
 
# count
df_all_genetic_pairs_pheno_mortality_switches %>%
  select(iso1, iso2, switches) %>%
  distinct() %>%
  count(switches)

rm(df_all_genetic_pairs_pheno)
```

# Pairs with contrasting persistence phenotype (non persistent-persistent)

## Import persistence data and generate pairs

```{r}
clinical_outcomes_data <- read_csv("plate_info/strain_metadata.csv")%>%
  left_join(read_csv("../VANESSA_ANZCOSS/dataframes/pop_structure_n747_clinical_outcomes.csv"), by = c("sample_id" = "mdu_id")) 


# persist_single_strain <- clinical_outcomes_data %>%
#   filter(is.na(included) | !included) %>%
#   mutate(persistent = case_when(
#     durationofsab >= 7 ~ T,
#     recurrent_sab == 1 ~ T,
#     is.na(durationofsab) & is.na(recurrent_sab) ~ NA,
#     TRUE ~ F
#   )) %>%
# select(sample_id, strain_group, persistent, included,  sample_type, intrahost_sampledelay, durationofsab, recurrent_sab) %>%
#   select(sample_id, strain_group, persistent, durationofsab, recurrent_sab)

# first flag persistent strains in episodes with one isolate per patient or multiple unrelated isolates
persist_single_strain <- clinical_outcomes_data %>%
  filter(blood_sample) %>% # mask isolates collected from non blood sites
  filter(is.na(included) | !included) %>% # mask genetically matched same-patient isolates (included)
 mutate(persistent = F) %>% # set all these isolates to non persistent since we don't have any data to support persistence or recurrence (they might be assocaited with an episode with long duration of bacteraemia but this happened later during the infection so we assume there were mutations in later isolates that we didn't collect)
# select(sample_id, strain_group, persistent, included,  sample_type, intrahost_sampledelay, durationofsab, recurrent_sab) %>%
  select(sample_id, strain_group, persistent, durationofsab, recurrent_sab)

# now flag persistent strains in episodes with more than one genetically matched same-patient isolates
persist_multiple_strains <- clinical_outcomes_data %>%
  filter(included) %>% # mask single isolates and genetically unmatched isolates from the same patient
  filter(blood_sample) %>% # # mask isolates collected from non blood sites
  mutate(long_delay = intrahost_sampledelay >= 7) %>% 
  group_by(strain_group) %>%
  # mutate(persistent_group = any(long_delay, durationofsab >= 7, recurrent_sab == 1, na.rm = T)) %>%
  mutate(persistent_group = any(long_delay, na.rm = T)) %>%
  arrange(desc(intrahost_sampledelay)) %>%
  mutate(persistent = persistent_group & row_number() == 1) %>%
  # select(sample_id, strain_group, included, persistent_group, persistent, sample_type, intrahost_sampledelay, durationofsab, recurrent_sab) %>%
  select(sample_id, strain_group, persistent, durationofsab, recurrent_sab)

df_persist <- clinical_outcomes_data %>%
  left_join(bind_rows(persist_single_strain, persist_multiple_strains)) %>%
  mutate(persistent = if_else(persistent, "Persistent", "Non persistent")) %>%
  # select(sample_id, strain_group, included, persistent, sample_type, intrahost_sampledelay, durationofsab, recurrent_sab) %>%
  select(sample_id, persistent, durationofsab, recurrent_sab)

# df_persist %>%
#   filter(is.na(persistent)) %>%
#   count(sample_type, included, durationofsab, recurrent_sab)

df_all_genetic_pairs_pheno_mortality_persist_switches <- df_all_genetic_pairs_pheno_mortality_switches %>%
  left_join(df_persist, by = c("iso1" = "sample_id")) %>%
  rename_at(vars(persistent,durationofsab, recurrent_sab),
            funs(str_c("iso1_", .))) %>%
  left_join(df_persist, by = c("iso2" = "sample_id")) %>%
  rename_at(vars(persistent, durationofsab, recurrent_sab),
            funs(str_c("iso2_", .))) %>%
  mutate(persist_switch = str_c(iso1_persistent,"-", iso2_persistent)) %>%
  left_join(df_phenotypes %>% select(iso1, iso2, starts_with("delta")))
  # select(iso1, iso2, persist_switch,
  #        contains("strain_group"),
  #        contains("persistent"),
  #        contains("sample_type"),
  #        contains("intrahost_sampledelay"),
  #        contains("durationofsab"),
  #        contains("recurrent_sab"))

write_csv(df_all_genetic_pairs_pheno_mortality_persist_switches,
          "Ideas_Grant_2020_analysis/Genetic_pairs_table/genetic_pairs_pheno_changes_mortality_persist_switches.csv")

rm(df_all_genetic_pairs_pheno_mortality_switches, df_persist, persist_multiple_strains, persist_single_strain, clinical_outcomes_data)
```

# Analyse contrasting clinical outcomes and in vitro phenotypes

##  mortality switches

### Generate dataset of clusters of mortality switches

```{r}
df_mortality_close_clusters <- df_all_genetic_pairs_pheno_mortality_persist_switches %>%
  arrange(iso2) %>%
  filter(switches %in% c("Survived-Died")) %>%
  group_by(iso2) %>%
  mutate(iso_cluster = str_c(iso2, "-cluster")) %>%
  select(iso1, iso2, switches, iso_cluster, dist, contains("_ST")) 



df_mortality_close_clusters %>%
  .$iso_cluster %>%
  n_distinct()

df_mortality_close_clusters %>%
  .$iso1 %>%
  n_distinct()
  
df_mortality_close_clusters %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()
```

# Alternative way to generate a dataset

The clusters we have generated use the same control for multiple cases. This is problematic because it means that clusters are not independent and therefore we overestimate convergence.

To remove redundant controls, we first generate a datafrane of 28 independent pairs (one case - one control). We then select supplementary controls from a reserve of isolates that are not already incldued in the independent pairs.

The final dataframe of clusters with no redudant controls consists of 77 pairs including 28 cases and 76 controls, meaning that only one control is used twice. This is due to the structure of the dataset with many cases and controls belonging to the clonal ST239. If we want to remove redundant controls completely we have to remove one case.

```{r}
df_mortality_close_pairs <- df_mortality_close_clusters %>%
  group_by(iso1) %>%
  mutate(n = n()) %>%
  arrange(n) %>%
  group_by(iso_cluster) %>%
  filter(row_number() == 1) %>%
  select(iso1, iso2, switches, iso_cluster, dist, contains("_ST")) %>%
  mutate(dataset = "pairs")

df_mortality_close_pairs %>%
  .$iso_cluster %>%
  n_distinct()

iso1_pairs <- sort(df_mortality_close_pairs$iso1)

iso1_reserve <- df_mortality_close_clusters %>%
  filter(!iso1 %in% iso1_pairs) %>%
  .$iso1 %>%
  unique() %>%
  sort()

df_mortality_close_clusters_reserve <- df_mortality_close_clusters %>%
  filter(iso1 %in% iso1_reserve) %>%
  ungroup() %>%
  arrange(iso1) %>%
  distinct(iso1, .keep_all = T) %>%
  mutate(dataset = "reserve")

df_mortality_close_clusters_no_redundancy <- bind_rows(df_mortality_close_pairs, 
                                 df_mortality_close_clusters_reserve)

df_mortality_close_clusters_no_redundancy %>%
  .$iso_cluster %>%
  n_distinct()

df_mortality_close_clusters_no_redundancy %>%
  .$iso1 %>%
  n_distinct()
  
df_mortality_close_clusters_no_redundancy %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()

rm(iso1_pairs, iso1_reserve, df_mortality_close_clusters_reserve, df_mortality_close_clusters, df_mortality_close_pairs)
```

### Convergence analysis of mortality

```{r}
df_mutations_mortality_close_clusters <- snippy_data_modified_proteins %>%
  right_join(df_mortality_close_clusters_no_redundancy) 

df_convergence_mortality_clusters <- df_mutations_mortality_close_clusters %>%
  drop_na(clstr_prot) %>%
  filter(EFFTYPE != "synonymous_variant") %>%
  group_by(clstr_prot, clstr_size_prot) %>%
   mutate(n_clusters = n_distinct(iso_cluster), 
          n_pairs = n_distinct(PAIR_ID),
         n_references = n_distinct(REFERENCE),
         n_st = n_distinct(iso2_ST),
         n_positions = n_distinct(AA_POS)) %>%
  select(n_references, n_clusters, n_pairs, n_st, n_positions, clstr_prot, clstr_size_prot, GENE, PRODUCT, MUTATION_SHORT, iso_cluster, PAIR_ID, switches, everything()) %>%
  arrange(clstr_prot, desc(n_clusters))

t_mortality_clusters <- df_convergence_mortality_clusters %>%
 group_by(clstr_prot) %>%
  mutate(SEQUENCE_prot = SEQUENCE_prot[1]) %>%
  distinct(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, GENE, PRODUCT, MUTATION_SHORT, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  group_by(n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  summarise_at(vars(GENE, PRODUCT, MUTATION_SHORT),
               funs(str_c(unique(.), collapse = "|"))) %>%
  mutate(phenotype = "SAB mortality") %>%
  arrange(desc(n_clusters))
t_mortality_clusters
```

##  persistence

### Generate dataset of clusters of persistence switches

```{r}
df_persist_close_clusters <- df_all_genetic_pairs_pheno_mortality_persist_switches %>%
  arrange(iso2) %>%
  filter(persist_switch %in% c("Non persistent-Persistent")) %>%
  group_by(iso2) %>%
  mutate(iso_cluster = str_c(iso2, "-cluster")) %>%
  select(iso1, iso2, persist_switch, iso_cluster, dist, contains("_ST")) 



df_persist_close_clusters %>%
  .$iso_cluster %>%
  n_distinct()

df_persist_close_clusters %>%
  .$iso1 %>%
  n_distinct()
  
df_persist_close_clusters %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()
```

## Alternative way to generate a dataset

The clusters we have generated use the same control for multiple cases. This is problematic because it means that clusters are not independent and therefore we overestimate convergence.

To remove redundant controls, we first generate a datafrane of 28 independent pairs (one case - one control). We then select supplementary controls from a reserve of isolates that are not already incldued in the independent pairs.

The final dataframe of clusters with no redudant controls consists of 77 pairs including 28 cases and 76 controls, meaning that only one control is used twice. This is due to the structure of the dataset with many cases and controls belonging to the clonal ST239. If we want to remove redundant controls completely we have to remove one case.

```{r}
df_persist_close_pairs <- df_persist_close_clusters %>%
  group_by(iso1) %>%
  mutate(n = n()) %>%
  arrange(n) %>%
  group_by(iso_cluster) %>%
  filter(row_number() == 1) %>%
  select(iso1, iso2, persist_switch, iso_cluster, dist, contains("_ST")) %>%
  mutate(dataset = "pairs")

df_persist_close_pairs %>%
  .$iso_cluster %>%
  n_distinct()

iso1_pairs <- sort(df_persist_close_pairs$iso1)

iso1_reserve <- df_persist_close_clusters %>%
  filter(!iso1 %in% iso1_pairs) %>%
  .$iso1 %>%
  unique() %>%
  sort()

df_persist_close_clusters_reserve <- df_persist_close_clusters %>%
  filter(iso1 %in% iso1_reserve) %>%
  ungroup() %>%
  arrange(iso1) %>%
  distinct(iso1, .keep_all = T) %>%
  mutate(dataset = "reserve")

df_persist_close_clusters_no_redundancy <- bind_rows(df_persist_close_pairs, 
                                 df_persist_close_clusters_reserve)

df_persist_close_clusters_no_redundancy %>%
  .$iso_cluster %>%
  n_distinct()

df_persist_close_clusters_no_redundancy %>%
  .$iso1 %>%
  n_distinct()
  
df_persist_close_clusters_no_redundancy %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()

rm(iso1_pairs, iso1_reserve, df_persist_close_clusters_reserve, df_persist_close_clusters, df_persist_close_pairs)
```

## Convergence analysis of persistence

```{r}
df_mutations_persist_close_clusters <- snippy_data_modified_proteins %>%
  right_join(df_persist_close_clusters_no_redundancy) 

df_convergence_persist_clusters <- df_mutations_persist_close_clusters %>%
  drop_na(clstr_prot) %>%
  filter(EFFTYPE != "synonymous_variant") %>%
  group_by(clstr_prot, clstr_size_prot) %>%
   mutate(n_clusters = n_distinct(iso_cluster), 
          n_pairs = n_distinct(PAIR_ID),
         n_references = n_distinct(REFERENCE),
         n_st = n_distinct(iso2_ST),
         n_positions = n_distinct(AA_POS)) %>%
  select(n_references, n_clusters, n_pairs, n_st, n_positions, clstr_prot, clstr_size_prot, GENE, PRODUCT, MUTATION_SHORT, iso_cluster, PAIR_ID, persist_switch, everything()) %>%
  arrange(clstr_prot, desc(n_clusters))

t_persist_clusters <- df_convergence_persist_clusters %>%
 group_by(clstr_prot) %>%
  mutate(SEQUENCE_prot = SEQUENCE_prot[1]) %>%
  distinct(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, GENE, PRODUCT, MUTATION_SHORT, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  group_by(n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  summarise_at(vars(GENE, PRODUCT, MUTATION_SHORT),
               funs(str_c(unique(.), collapse = "|"))) %>%
  mutate(phenotype = "SAB persistence") %>%
  arrange(desc(n_clusters))
```


## growth rate

### Explore growth rate

```{r}
for (var in str_subset(colnames(df_phenotypes), "iso1_.*_OD")){
  p <- ggdensity(data = df_phenotypes, x = var, fill = "red") +
    theme_bw()
  
  print(p)
}
```

```{r}
df_plot <- df_phenotypes %>%
  mutate_at(vars(matches("delta_.*_OD")),
            abs)

for (var in str_subset(colnames(df_plot), "delta_.*_OD")){
  p <- ggdensity(data = df_plot, x = var, fill = "red") +
    theme_bw()
  
  print(p)
}
```

### Generate dataset of clusters of discordant growth 

Based on the exploration above, we define a delta AUC threshold of 20 for discordant pairs (30 would be a more stringent one, but we know from the within-host evolution analysis that VSS-137 has a difference of 21).

*An alternative way would be to define isolates with* **low growth rate** *(eg AUC less than 80 based on the density plot) and then select controls with high AUC*

### Dataset of clusters with redundant controls

```{r}
df_growth_close_clusters <- df_phenotypes %>%
  arrange(iso2) %>%
  filter(delta_AUC_OD < - 20) %>%
  group_by(iso2) %>%
  mutate(iso_cluster = str_c(iso2, "-cluster")) %>%
  select(iso1, iso2, iso_cluster, dist, contains("AUC_OD"), contains("_ST"), contains("CC"))

### Alternative way
# df_growth_close_clusters <- df_phenotypes %>%
#   arrange(iso2) %>%
#   filter(iso2_AUC_OD < 80 & iso1_AUC_OD >= 80) %>%
#   group_by(iso2) %>%
#   mutate(iso_cluster = str_c(iso2, "-cluster")) %>%
#   select(iso1, iso2, iso_cluster, dist, contains("AUC_OD"))

df_growth_close_clusters %>%
  .$iso_cluster %>%
  n_distinct()

df_growth_close_clusters %>%
  .$iso1 %>%
  n_distinct()
  
df_growth_close_clusters %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()
```

### Dataset of pairs and clusters with no redundancy

Here we must avoid that the same strains is iso1 and iso2 at the same time.

Also if two iso2 have the same iso1 we can merge them in one cluster

```{r}
iso2 <- unique(df_growth_close_clusters$iso2)

df_prepare <- df_growth_close_clusters %>%
  ungroup() %>%
  filter(!iso1 %in% iso2) %>%
  group_by(iso2) %>%
  mutate(iso1_all = str_c(sort(iso1), collapse = "")) %>%
  group_by(iso1_all) %>%
  mutate(iso_cluster = iso_cluster[1])


df_growth_close_pairs <- df_prepare %>%
  group_by(iso1) %>%
  mutate(n = n()) %>%
  arrange(n) %>%
  group_by(iso_cluster) %>%
  filter(row_number() == 1) %>%
  mutate(dataset = "pairs")

df_growth_close_pairs %>%
  .$iso_cluster %>%
  n_distinct()

iso1_pairs <- sort(df_growth_close_pairs$iso1)

iso1_reserve <- df_prepare %>%
  filter(!iso1 %in% iso1_pairs) %>%
  filter(!iso1 %in% iso2) %>%
  .$iso1 %>%
  unique() %>%
  sort()

df_growth_close_clusters_reserve <- df_prepare %>%
  filter(iso1 %in% iso1_reserve) %>%
  ungroup() %>%
  arrange(iso1) %>%
  distinct(iso1, .keep_all = T) %>%
  mutate(dataset = "reserve")

df_growth_close_clusters_no_redundancy <- bind_rows(df_growth_close_pairs, 
                                 df_growth_close_clusters_reserve)

df_growth_close_clusters_no_redundancy %>%
  .$iso_cluster %>%
  n_distinct()

df_growth_close_clusters_no_redundancy %>%
  .$iso1 %>%
  n_distinct()

df_growth_close_clusters_no_redundancy %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()

rm(iso2, iso1_pairs, iso1_reserve, df_growth_close_clusters_reserve, df_growth_close_clusters, df_growth_close_pairs)
```

### Convergence analysis of growth

```{r message=F}
df_mutations_growth_close_clusters <- snippy_data_modified_proteins %>%
  right_join(df_growth_close_clusters_no_redundancy) 
nrow(df_mutations_growth_close_clusters)

df_convergence_growth_clusters <- df_mutations_growth_close_clusters %>%
  drop_na(clstr_prot) %>%
  filter(EFFTYPE != "synonymous_variant") %>%
  group_by(clstr_prot, clstr_size_prot) %>%
   mutate(n_clusters = n_distinct(iso_cluster), 
          n_pairs = n_distinct(PAIR_ID),
         n_references = n_distinct(REFERENCE),
         n_positions = n_distinct(AA_POS),
         n_st = n_distinct(iso2_ST)) %>%
  select(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, GENE, PRODUCT, MUTATION_SHORT, iso_cluster, PAIR_ID, delta_AUC_OD, everything()) %>%
  arrange(desc(n_clusters), desc(n_positions), clstr_prot)

t_growth_clusters <- df_convergence_growth_clusters %>%
 group_by(clstr_prot) %>%
  mutate(SEQUENCE_prot = SEQUENCE_prot[1]) %>%
  distinct(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, GENE, PRODUCT, MUTATION_SHORT, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  group_by(n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  summarise_at(vars(GENE, PRODUCT, MUTATION_SHORT),
               funs(str_c(unique(.), collapse = "|"))) %>%
  mutate(phenotype = "Growth rate (AUC)") 
```

# Convergence analysis of cytotoxicity

## Explore cytotoxicity

```{r}
for (var in str_subset(colnames(df_phenotypes), "iso1_.*_death")){
  p <- ggdensity(data = df_phenotypes, x = var, fill = "blue") +
    theme_bw()
  
  print(p)
}
```


```{r}
df_plot <- df_phenotypes %>%
  mutate_at(vars(matches("delta_.*_death")),
            abs)

for (var in str_subset(colnames(df_plot), "delta_.*_death")){
  p <- ggdensity(data = df_plot, x = var, fill = "blue") +
    theme_bw()
  
  print(p)
}
```


### Generate dataset of clusters of discordant cell death (with redundant controls)

Based on the exploration above, we define a delta AUC threshold of 40 for discordant pairs.

*An alternative way would be to define isolates with* **low growth rate** *(eg AUC less than 100 based on the density plot) and then select controls with high AUC*

```{r}
df_cell_death_close_clusters <- df_phenotypes %>%
  arrange(iso2) %>%
  filter(delta_AUC_death < - 40) %>%
  group_by(iso2) %>%
  mutate(iso_cluster = str_c(iso2, "-cluster"), 
         n = n()) %>%
  select(iso1, iso2, iso_cluster, dist, contains("AUC_death"), contains("_ST"), contains("CC"))

df_cell_death_close_clusters %>%
  .$iso_cluster %>%
  n_distinct()

df_cell_death_close_clusters %>%
  .$iso1 %>%
  n_distinct()
  
df_cell_death_close_clusters %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()
```

### Dataset of pairs and cluster with no redundancy

Here, we were able to generate a genuine dataframe with no redundant controls. Lenght of the dataframe is 20, as is the number of controls!

```{r}
iso2 <- unique(df_cell_death_close_clusters$iso2)

df_prepare <- df_cell_death_close_clusters %>%
  ungroup() %>%
  filter(!iso1 %in% iso2) %>%
  group_by(iso2) %>%
  mutate(iso1_all = str_c(sort(iso1), collapse = "")) %>%
  group_by(iso1_all) %>%
  mutate(iso_cluster = iso_cluster[1])

df_cell_death_close_pairs <- df_prepare %>%
  group_by(iso1) %>%
  mutate(n = n()) %>%
  arrange(n) %>%
  group_by(iso_cluster) %>%
  filter(row_number() == 1) %>%
  mutate(dataset = "pairs")

df_cell_death_close_pairs %>%
  .$iso_cluster %>%
  n_distinct()

iso1_pairs <- sort(df_cell_death_close_pairs$iso1)

iso1_reserve <- df_prepare %>%
  filter(!iso1 %in% iso1_pairs) %>%
  filter(!iso1 %in% iso2) %>%
  .$iso1 %>%
  unique() %>%
  sort()

df_cell_death_close_clusters_reserve <- df_prepare %>%
  filter(iso1 %in% iso1_reserve) %>%
  ungroup() %>%
  arrange(iso1) %>%
  distinct(iso1, .keep_all = T) %>%
  mutate(dataset = "reserve")

df_cell_death_close_clusters_no_redundancy <- bind_rows(df_cell_death_close_pairs, 
                                 df_cell_death_close_clusters_reserve)

df_cell_death_close_clusters_no_redundancy %>%
  .$iso_cluster %>%
  n_distinct()

df_cell_death_close_clusters_no_redundancy %>%
  .$iso1 %>%
  n_distinct()

df_cell_death_close_clusters_no_redundancy %>%
  ggplot(aes(x = fct_infreq(iso_cluster))) +
  geom_bar() +
  coord_flip() +
  labs(x = "") +
  theme_bw()

rm(iso2, iso1_pairs, iso1_reserve, df_cell_death_close_clusters_reserve, df_prepare, df_cell_death_close_clusters, df_cell_death_close_pairs)
```


```{r}
# df_cell_death_close_pairs <- df_cell_death_close_clusters %>%
#   group_by(iso1) %>%
#   mutate(n = n()) %>%
#   arrange(n) %>%
#   group_by(iso_cluster) %>%
#   filter(row_number() == 1) %>%
#   mutate(dataset = "pairs")
# 
# df_cell_death_close_pairs %>%
#   .$iso_cluster %>%
#   n_distinct()
# 
# iso1_pairs <- sort(df_cell_death_close_pairs$iso1)
# 
# iso1_reserve <- df_cell_death_close_clusters %>%
#   filter(!iso1 %in% iso1_pairs) %>%
#   .$iso1 %>%
#   unique() %>%
#   sort()
# 
# df_cell_death_close_clusters_reserve <- df_cell_death_close_clusters %>%
#   filter(iso1 %in% iso1_reserve) %>%
#   ungroup() %>%
#   arrange(iso1) %>%
#   distinct(iso1, .keep_all = T) %>%
#   mutate(dataset = "reserve")
# 
# df_cell_death_close_clusters_no_redundancy <- bind_rows(df_cell_death_close_pairs, 
#                                  df_cell_death_close_clusters_reserve)
# 
# df_cell_death_close_clusters_no_redundancy %>%
#   .$iso_cluster %>%
#   n_distinct()
# 
# df_cell_death_close_clusters_no_redundancy %>%
#   .$iso1 %>%
#   n_distinct()
# 
# df_cell_death_close_clusters_no_redundancy %>%
#   ggplot(aes(x = fct_infreq(iso_cluster))) +
#   geom_bar() +
#   coord_flip() +
#   labs(x = "") +
#   theme_bw()
# 
# rm(iso1_pairs, iso1_reserve, df_cell_death_close_clusters_reserve)
```

## Convergence analysis of cell death

```{r}
df_mutations_cell_death_close_clusters <- snippy_data_modified_proteins %>%
  right_join(df_cell_death_close_clusters_no_redundancy) 
nrow(df_mutations_cell_death_close_clusters)

df_convergence_cell_death_clusters <- df_mutations_cell_death_close_clusters %>%
  drop_na(clstr_prot) %>%
  filter(EFFTYPE != "synonymous_variant") %>%
  group_by(clstr_prot, clstr_size_prot) %>%
   mutate(n_clusters = n_distinct(iso_cluster), 
          n_pairs = n_distinct(PAIR_ID),
         n_references = n_distinct(REFERENCE),
         n_positions = n_distinct(AA_POS),
         n_st = n_distinct(iso2_ST)) %>%
  select(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, GENE, PRODUCT, MUTATION_SHORT, iso_cluster, PAIR_ID, delta_AUC_death, everything()) %>%
  arrange(desc(n_clusters), desc(n_positions), clstr_prot)

t_cell_death_clusters <- df_convergence_cell_death_clusters %>%
  group_by(clstr_prot) %>%
  mutate(SEQUENCE_prot = SEQUENCE_prot[1]) %>%
  distinct(n_references, n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, GENE, PRODUCT, MUTATION_SHORT, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  group_by(n_clusters, n_pairs, n_positions, n_st, clstr_prot, clstr_size_prot, SEQUENCE_prot, nebraska_locus_tag, neb_mutant_id, neb_gene, neb_product) %>%
  summarise_at(vars(GENE, PRODUCT, MUTATION_SHORT),
               funs(str_c(unique(.), collapse = "|"))) %>%
  mutate(phenotype = "Cell death (AUC)")
```

# Merge datasets

To keep the protein sequence, we select the first of the group. *In the future, we could select the representative sequence from cd-hit*

```{r message=F}
t <- bind_rows(t_mortality_clusters,
               t_persist_clusters,
               t_growth_clusters,
               t_cell_death_clusters)

collapse_variable <- function(var){
  # merge
  s_in <- str_c(unique(var), collapse = "|")
  # vectorise and find unique
  v <- str_split(s_in, "\\|", simplify = T)[1,] %>%
    unique()
  # transform into string
  s_out <- str_c(v, collapse = "|")
  return(s_out)
}

t_convergent <- t %>%
  ungroup() %>%
  select(clstr_prot,
         SEQUENCE_prot,
         starts_with("neb"),
         n_clusters,
         phenotype) %>%
  group_by(clstr_prot) %>%
  mutate(SEQUENCE_prot = SEQUENCE_prot[1]) %>%
  pivot_wider(
    names_from = phenotype,
    names_prefix = "n_clusters_",
    values_from = n_clusters,
    values_fill = list(n_clusters = 0)
  ) %>%
  left_join(t) %>%
  group_by_at(vars(
    clstr_prot,
    SEQUENCE_prot,
    starts_with("n_clusters_"),
    starts_with("neb")
  )) %>%
  summarise_at(vars(GENE, PRODUCT, MUTATION_SHORT),
               funs(collapse_variable(.)))

# add n_st and n_positions
t_st <- t %>%
  ungroup() %>%
  select(clstr_prot, n_st, phenotype) %>%
  pivot_wider(names_from = phenotype, names_prefix = "n_st_", values_from = n_st)

t_positions <- t %>%
  ungroup() %>%
  select(clstr_prot, n_positions, phenotype) %>%
  pivot_wider(names_from = phenotype, names_prefix = "n_positions_", values_from = n_positions)

t_convergent <- t_convergent %>%
  left_join(t_st) %>%
  left_join(t_positions) %>%
  select(clstr_prot, SEQUENCE_prot, starts_with("n_"), everything()) %>%
  ungroup() %>%
  mutate_at(vars(starts_with("n_")),
            funs(if_else(is.na(.), 0, as.double(.))))
```

# Summarise data (for Venn diagram): all mutated genes

```{r}
t_venn <- t_convergent %>%
  ungroup() %>%
  mutate_at(vars(starts_with("n_clusters")),
            funs(mutated = as.integer(. > 0))) %>%
  unite(col = "intersect", ends_with("mutated"), sep = "") %>%
  mutate(intersect = recode(intersect,
                            `1111` = "all",
                            `1000` = "SAB mortality only",
                            `1100` = "SAB mortality and SAB persistence",
                            `1110` = "SAB mortality, SAB persistence and growth rate",
                            `1101` = "SAB mortality, SAB persistence and cell death",
                            `1010` = "SAB mortality and growth rate",
                            `1011` = "SAB mortality, growth rate and cell death",
                            `1001` = "SAB mortality and cell death",
                            `0100` = "SAB persistence only",
                            `0101` = "SAB persistence and cell death",
                            `0110` = "SAB persistence and growth rate",
                            `0111` = "SAB persistence, growth rate and cell death",
                            `0011` = "Growth rate and cell death",
                            `0010` = "Growth rate only",
                            `0001` = "Cell death only"))

write_csv(t_venn, 
          "Ideas_Grant_2020_analysis/Convergence_analysis_tables/convergence_analysis_clusters_no_redundant_controls.csv")

t_venn_synthesis <- t_venn %>%
  count(intersect)
```

# Summarise data (for Venn diagram): genes mutated at least 2 times (convergent)

```{r}
t_venn_stringent <- t_convergent %>%
  ungroup() %>%
  mutate_at(vars(starts_with("n_clusters")),
            funs(mutated = as.integer(. > 1))) %>%
  unite(col = "intersect", ends_with("mutated"), sep = "") %>%
  filter(intersect != "0000") %>%
 mutate(intersect = recode(intersect,
                            `1111` = "all",
                            `1000` = "SAB mortality only",
                            `1100` = "SAB mortality and SAB persistence",
                            `1110` = "SAB mortality, SAB persistence and growth rate",
                            `1101` = "SAB mortality, SAB persistence and cell death",
                            `1010` = "SAB mortality and growth rate",
                            `1011` = "SAB mortality, growth rate and cell death",
                            `1001` = "SAB mortality and cell death",
                            `0100` = "SAB persistence only",
                            `0101` = "SAB persistence and cell death",
                            `0110` = "SAB persistence and growth rate",
                            `0111` = "SAB persistence, growth rate and cell death",
                            `0011` = "Growth rate and cell death",
                            `0010` = "Growth rate only",
                            `0001` = "Cell death only"))

write_csv(t_venn_stringent, 
          "Ideas_Grant_2020_analysis/Convergence_analysis_tables/convergence_analysis_clusters_no_redundant_controls_stringent.csv")

t_venn_stringent_synthesis <- t_venn_stringent %>%
  count(intersect)
```

# Merge all convergence tables in one

## non redundant clusters only

```{r}
df_convergence_all <- df_convergence_mortality_clusters %>%
  full_join(df_convergence_persist_clusters) %>%
  full_join(df_convergence_growth_clusters) %>%
  full_join(df_convergence_cell_death_clusters)

# write_csv(df_convergence_all,
#           "Ideas_Grant_2020_analysis/Convergence_analysis_tables/convergence_analysis_clusters_no_redundant_controls_all_pairs.csv")
```

## all pairs with metadata

```{r}
df_mutations_mortality_phenotypes <- snippy_data_modified_proteins %>%
  left_join(df_all_genetic_pairs_pheno_mortality_persist_switches) %>%
  left_join(df_phenotypes)

# write_csv(df_mutations_mortality_phenotypes,
#           "Ideas_Grant_2020_analysis/Convergence_analysis_tables/snippy_data_mortality_phenotypes_switches.csv")
```

## Generate an upset plot 

could also use Intervene (https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-017-1708-7)

upsetR package (http://caleydo.org/tools/upset/)

```{r}
# install.packages("UpSetR")
library(UpSetR)

movies <- read.csv(system.file("extdata", "movies.csv", package = "UpSetR"), 
    header = T, sep = ";")
str(movies)

upset(movies)

t_convergent_upset <- t_convergent %>%
  transmute(clstr_prot = str_c("cluster-", clstr_prot), mortality = `n_clusters_SAB mortality`, `persistent infection` = `n_clusters_SAB persistence`, growth = `n_clusters_Growth rate (AUC)`, `cell death` = `n_clusters_Cell death (AUC)`) %>%
  mutate_if(is.numeric, 
            funs(as.integer(. > 0))) %>%
  as.data.frame()

pdf("Ideas_Grant_2020_analysis/figures/convergence_plots/upset_plot.pdf", width = 5, height = 3, useDingbats = F)
upset(data = t_convergent_upset, nsets = 4, order.by = "degree", main.bar.color = "#084081", sets.bar.color = "#7bccc4", sets.x.label = "Number of mutated genes")
dev.off()

```

# Plot pairs on the tree

# All genetic pairs

```{r}
tree <- read.tree("Ideas_Grant_2020_analysis/Raw_data/genetic_pairs.tree") %>%
  # ape::root(c("BPH2704", "BPH2705"))
  phytools::midpoint.root()
p <- ggtree(tree, layout = "circular")
p
```

## Plot major STs on the tree

```{r}
# dataframe with all metadata
df_metadata <- read_csv("Ideas_Grant_2020_analysis/Genetic_pairs_table/df_all_genetic_pairs_pheno.csv") %>%
  select(sample_id = iso1, ST = iso1_ST, mortality = iso1_mortality, AUC_death = iso1_AUC_death, AUC_OD = iso1_AUC_OD) %>%
  distinct()

# add mortality
matrix <- df_metadata %>%
  column_to_rownames("sample_id")

p2 <- gheatmap(p, matrix %>% select(mortality), width = .05, colnames = F, color = NA) +
  # geom_tiplab2() +
  scale_fill_manual(values = c("orange", "navy"), name = "Patient outcome", guide = guide_legend(order = 1), na.translate = F)
p2

library(ggnewscale)
p3 <- p2 + new_scale_fill()

p4 <- gheatmap(p3, matrix %>%
           select(AUC_death), width = .05, offset = .015, colnames = F, color = NA) +
  scale_fill_viridis_c(direction = -1, na.value = "white", name = "PI uptake (AUC)")
p5 <- p4 + new_scale_fill()
p6 <- gheatmap(p5, matrix %>%
           select(AUC_OD), width = .05, offset = .03, colnames = F, color = NA) +
  scale_fill_viridis_c(option = "plasma", direction = -1, na.value = "white", name = "Growth (OD AUC)")
p6


get_st_mrca <- function(st){
  tips <- df_metadata %>%
    filter(ST == st) %>%
    .$sample_id
  node <- ape::getMRCA(tree, tips)
  return(node)
}

# get_st_mrca("239")
p7 <- p6
for (i in df_metadata %>% filter(ST != "-") %>% count(ST, sort = T) %>% slice(1:5) %>% .$ST){
  p7 <- p7 +
    geom_cladelabel(node = get_st_mrca(i), label = str_c("ST", i), offset = .06, offset.text = .003, align = T)
}
p7

ggsave("Ideas_Grant_2020_analysis/figures/trees/genetic_pairs_tree.pdf", width = 5, height = 4)
```


## Mortality tree

### List of paired isolates included in the paired analysis

```{r}
df_mortality_close_clusters_long <- df_mortality_close_clusters_no_redundancy %>%
  select(-switches) %>%
  ungroup() %>%
  pivot_longer(iso1:iso2, names_to = "iso_rank", values_to = "ISOLATE") %>%
  distinct() %>%
  transmute(ISOLATE, iso_cluster, mortality = if_else(iso_rank == "iso2", "Died", "Survived")) %>%
  # add metadata
  left_join(df_all_genetic_pairs_pheno_mortality_persist_switches %>% select(starts_with("iso1")) %>% distinct() %>% rename(ISOLATE = iso1) %>% rename_at(vars(starts_with("iso1")), funs(str_remove(., "iso1_"))))

# # Add some metadata
# df_genetic_pairs_unique <- df_all_genetic_pairs_pheno %>%
#   select(starts_with("iso1")) %>%
#   distinct() %>%
#   rename(ISOLATE = iso1) %>%
#   rename_at(vars(starts_with("iso1")),
#             funs(str_remove(., "iso1_")))
# df_mortality_close_clusters_long_with_metadata <- df_mortality_close_clusters_long %>%
#   left_join(df_genetic_pairs_unique)

# List of unique isolates
mortality_close_clusters_no_redundancy <- sort(unique(df_mortality_close_clusters_long$ISOLATE))
write_lines(mortality_close_clusters_no_redundancy, "Ideas_Grant_2020_analysis/Genetic_pairs_table/mortality_close_clusters_no_redundancy.txt")
```

## Import tree

```{r}
mortality_tree <- read.tree("Ideas_Grant_2020_analysis/Raw_data/mortality_close_clusters_no_redundancy.tree") %>%
  phytools::midpoint.root()
mortality_tree <- drop.tip(mortality_tree, "Reference")

p <- ggtree(mortality_tree, layout = "circular")
p +
  # geom_tiplab2() +
  geom_treescale()
```

## Annotate tree with mortality and CC

Annotation rings: 1) mortality, 2) CC. Outer rings show the top convergent genes with different colors for each mutation

```{r}
metadata_matrix <- df_mortality_close_clusters_long %>%
  select(ISOLATE, CC, mortality) %>%
  distinct() %>%
  column_to_rownames("ISOLATE")
p2 <- gheatmap(p, metadata_matrix %>% select(mortality), width = .1, colnames = F) +
  # geom_tiplab2() +
  scale_fill_manual(values = c("orange", "navy"), name = "Patient outcome", guide = guide_legend(order = 1)) 
p2

library(ggnewscale)
p3 <- p2 + new_scale_fill()

p4 <- gheatmap(p3, metadata_matrix %>%
           select(CC), width = .1, offset = .1) +
  scale_fill_viridis_d()
p4

```

## Annotate tree with convergent genes

We can show a maximum of 10 genes (maybe 5). Need to prioritise convergent genes in terms of number of cluster, number of ST, number of positions. Also flag whether the genes were identified using the other approaches.

## Add information about intersection with other datasets

```{r}
df_genes <- t_mortality_clusters %>%
  left_join(t_convergent_upset %>% mutate(clstr_prot = as.numeric(str_remove(clstr_prot, "cluster-")))) %>%
  mutate(intersection = any(growth ==1, `cell death` == 1))
```


```{r}
top_genes <- df_genes %>%
  arrange(desc(n_clusters), desc(n_st)) %>%
  ungroup() %>%
  slice(1:10)
  # group_by(intersection) %>%
  # slice(1:5)
  

df_top_genes <- df_convergence_mortality_clusters %>%
  ungroup() %>%
  right_join(top_genes %>% select(clstr_prot, intersection)) %>%
  distinct(n_clusters, ISOLATE, clstr_prot, GENE, PRODUCT, neb_mutant_id, neb_gene, neb_product, MUTATION_SHORT, intersection) %>%
  group_by(clstr_prot, intersection) %>%
  mutate(gene_length = if_else(!is.na(GENE),
                              str_length(GENE), 
                              NA_integer_)) %>%
  mutate(min_gene_length = if_else(!is.na(GENE),
                              min(str_length(GENE)), 
                              NA_integer_)) %>%
  arrange(min_gene_length) %>%
  mutate(gene_label = GENE[1]) %>%
  mutate(gene_label = if_else(is.na(gene_label),
                              str_c("HP-", clstr_prot),
                              gene_label)) %>%
  group_by(gene_label, ISOLATE, intersection) %>%
  mutate(allele = str_c(MUTATION_SHORT, collapse = " ")) %>%
  mutate(gene_mutation = str_c(gene_label, allele, sep = " "))

# top_genes_matrix <- df_top_genes %>%
#   distinct(ISOLATE, clstr_prot) %>%
#   mutate(mutated = T) %>%
#   pivot_wider(names_from = clstr_prot, values_from = mutated, values_fill = list(mutated = F)) %>%
#   column_to_rownames("ISOLATE")

# top_genes_matrix <- df_top_genes %>%
#   ungroup() %>%
#   distinct(ISOLATE, gene_label, gene_mutation) %>%
#   pivot_wider(names_from = gene_label, values_from = gene_mutation) %>%
#   column_to_rownames("ISOLATE")


df_top_genes_simple <- df_top_genes %>%
  ungroup() %>%
  distinct(label = ISOLATE, gene_label, allele)

top_genes_matrix <- df_top_genes_simple %>%
  pivot_wider(names_from = gene_label, values_from = allele) %>%
  column_to_rownames("label")

p5 <- p4 + new_scale_fill()

# p6 <- gheatmap(p3, top_genes_matrix, offset = .2, colnames = F) +
#    scale_fill_manual(values = c("white", "red"))
 p6 <- gheatmap(p3, top_genes_matrix, offset = .2, colnames = F) +
   scale_fill_discrete(guide = F, na.value = "white")


# 
# p6 <- p3 %<+% df_top_genes  +
#   geom_point2(aes(subset = gene_label == "ebh", shape = allele), 
#               x = .7)


p6

ggsave("Ideas_Grant_2020_analysis/figures/mortality_clusters_no_redundancy_tree.pdf")
```


### Tree with first 5 convergent genes

Start with genes that were identified in other approaches

```{r}
library(RColorBrewer)
# vector of palettes
pal <- brewer.pal.info %>%
  rownames_to_column("palette") %>%
  filter(category == "seq") %>%
  mutate(multi_hue = str_detect(palette, "\\w[:upper:]")) %>%
  filter(multi_hue) %>%
  .$palette


matrix <- top_genes_matrix[,1:5]
p <- p3 
for (i in 1:length(colnames(matrix))){
  
  m <- top_genes_matrix[,i, drop = F]
  
  p <- p + new_scale_fill()
  
  p <- gheatmap(p, m, offset = .1 + .055*(i-1), width = .1, colnames = F, color = "grey") +
  scale_fill_brewer(palette = pal[i], na.translate = F, name = colnames(matrix)[i], guide = guide_legend(order = i+1, direction = "horizontal", nrow = 1, title.position = "top"),
                    labels = NULL)

}
p +
  theme(legend.spacing.x = unit(0, "cm"),
        legend.title = element_text(face = "bold", size = 18),
        legend.text = element_text(size = 16))

ggsave("Ideas_Grant_2020_analysis/figures/mortality_clusters_no_redundancy_tree.pdf")
```

## Tree with first 10 convergent genes

```{r}
# vector of palettes
pal <- brewer.pal.info %>%
  rownames_to_column("palette") %>%
  filter(category == "seq") %>%
  mutate(multi_hue = str_detect(palette, "\\w[:upper:]")) %>%
  filter(multi_hue) %>%
  .$palette
# list of palette 
l_pal <- lapply(pal, brewer.pal, n = 9)

matrix <- top_genes_matrix

p <- p3 
for (i in 1:length(colnames(matrix))){
  
  m <- top_genes_matrix[,i, drop = F]
  
  p <- p + new_scale_fill()
  
  p <- gheatmap(p, m, offset = .1 + .055*(i-1), width = .1, colnames = F, color = "#f0f0f0") +
  scale_fill_manual(values = l_pal[[i]][4:9], na.translate = F, name = colnames(matrix)[i], guide = guide_legend(order = i+1, direction = "horizontal", nrow = 1, title.position = "top"),
                    labels = NULL)
  # scale_fill_brewer(palette = pal[i], direction = -1, na.translate = F, name = colnames(matrix)[i], guide = guide_legend(order = i+1, direction = "horizontal", nrow = 1, title.position = "top"),
  #                   labels = NULL)

}
p +
  theme(legend.spacing.x = unit(0, "cm"),
        legend.title = element_text(face = "bold", size = 16),
        legend.text = element_text(size = 16))

ggsave("Ideas_Grant_2020_analysis/figures/mortality_clusters_no_redundancy_tree.pdf", width = 15, height = 11)
```


# Simplified tree for the graphical abstract

We need to show a tree with a contrastic phenotype and convergent mutations

## try with the mortality tree

```{r}

# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("ggtree")
# library(ggtree)

tree <- read.tree("Ideas_Grant_2020_analysis/Raw_data/mortality_close_clusters_no_redundancy.tree") %>%
  phytools::midpoint.root()
p <- ggtree(tree, layout = "circular")

top_genes_matrix_2 <- top_genes_matrix %>%
  rownames_to_column("iso") %>%
  mutate_at(vars(-iso), funs(as.factor(if_else(is.na(.), 0, 1)))) %>%
  column_to_rownames("iso")
top_genes_matrix_2 <- top_genes_matrix_2[,6:10]

gheatmap(p, top_genes_matrix_2, colnames = F, width = .4) +
  scale_fill_manual(values = c("white", "red"), guide = F)

ggsave("Ideas_Grant_2020_analysis/figures/trees/graphical_abstract_simplified_tree.pdf", width = 1, height = 1)

```


# Growth rate tree

## List of paired isolates included in the paired analysis

```{r}
df_growth_close_clusters_long <- df_growth_close_clusters_no_redundancy %>%
  ungroup() %>%
  select(iso1, iso2, iso_cluster) %>%
  pivot_longer(iso1:iso2, names_to = "iso_rank", values_to = "ISOLATE") %>%
  distinct() %>%
  transmute(ISOLATE, iso_cluster, growth_rate = if_else(iso_rank == "iso2", "Slow", "Fast"))

# Add some metadata
df_genetic_pairs_unique <- df_all_genetic_pairs_pheno %>%
  select(starts_with("iso1")) %>%
  distinct() %>%
  rename(ISOLATE = iso1) %>%
  rename_at(vars(starts_with("iso1")),
            funs(str_remove(., "iso1_")))
df_growth_close_clusters_long_with_metadata <- df_growth_close_clusters_long %>%
  left_join(df_genetic_pairs_unique)

# List of unique isolates
growth_close_clusters_no_redundancy <- sort(unique(df_growth_close_clusters_long$ISOLATE))
write_lines(growth_close_clusters_no_redundancy, "Ideas_Grant_2020_analysis/Genetic_pairs_table/growth_close_clusters_no_redundancy.txt")
```

## Import tree

```{r}
growth_tree <- read.tree("Ideas_Grant_2020_analysis/Raw_data/growth_close_clusters_no_redundancy.tree") %>%
  phytools::midpoint.root() %>%
  drop.tip("Reference")
p <- ggtree(growth_tree, layout = "circular")
p
```

## Annotate tree with convergent genes

```{r}
metadata_matrix <- df_growth_close_clusters_long_with_metadata %>%
  select(ISOLATE, ST, growth_rate) %>%
  distinct() %>%
  column_to_rownames("ISOLATE")
p2 <- gheatmap(p, metadata_matrix %>% select(growth_rate), width = .1, offset = .1, colnames = F) +
  scale_fill_manual(values = c("navy", "orange"), name = "Growth rate", guide = guide_legend(order = 1)) 
p2

# library(ggnewscale)
# p3 <- p2 + new_scale_fill()
# 
# p4 <- gheatmap(p3, metadata_matrix %>%
#             select(CC), offset = .2) +
#    scale_fill_viridis_d()
# p4

top_genes <- df_convergence_growth_clusters %>%
  ungroup() %>%
  arrange(desc(n_clusters), desc(n_st), desc(n_positions)) %>%
  ungroup() %>% distinct(clstr_prot) %>% filter(row_number() <= 5)

df_top_genes <- df_convergence_growth_clusters %>%
  ungroup() %>%
  filter(clstr_prot %in% top_genes$clstr_prot) %>%
  distinct(n_clusters, ISOLATE, clstr_prot, GENE, PRODUCT, neb_mutant_id, neb_gene, neb_product, MUTATION_SHORT) %>%
  group_by(clstr_prot) %>%
  mutate(gene_length = if_else(!is.na(GENE),
                              str_length(GENE), 
                              NA_integer_)) %>%
  arrange(gene_length) %>%
  mutate(gene_label = GENE[1]) %>%
  mutate(gene_label = if_else(is.na(gene_label),
                              str_c("HP-", clstr_prot),
                              gene_label)) %>%
  group_by(gene_label, ISOLATE) %>%
  mutate(allele = str_c(MUTATION_SHORT, collapse = " ")) %>%
  mutate(gene_mutation = str_c(gene_label, allele, sep = " "))

df_top_genes <- df_top_genes %>%
  ungroup() %>%
  distinct(label = ISOLATE, gene_label, allele)

top_genes_matrix <- df_top_genes %>%
  pivot_wider(names_from = gene_label, values_from = allele) %>%
  column_to_rownames("label")
```

```{r}
matrix <- top_genes_matrix[,1:5]
p <- p2
for (i in 1:length(colnames(matrix))){
  
  m <- top_genes_matrix[,i, drop = F]
  
  p <- p + new_scale_fill()
  
  p <- gheatmap(p, m, offset = .5 + .13*(i-1), width = .1, colnames = F, color = "grey") +
  scale_fill_brewer(palette = pal[i], na.translate = F, name = colnames(matrix)[i], guide = guide_legend(order = i+1, direction = "horizontal", nrow = 1, title.position = "top"),
                    labels = NULL)

}
p +
  theme(legend.spacing.x = unit(0, "cm"),
        legend.title = element_text(face = "bold", size = 18),
        legend.text = element_text(size = 16))

ggsave("Ideas_Grant_2020_analysis/figures/growth_clusters_no_redundancy_tree.pdf")
```


# Cell death  tree

## List of paired isolates included in the paired analysis

```{r}
df_cell_death_close_clusters_long <- df_cell_death_close_clusters_no_redundancy %>%
  ungroup() %>%
  select(iso1, iso2, iso_cluster) %>%
pivot_longer(iso1:iso2, names_to = "iso_rank", values_to = "ISOLATE") %>%
  distinct() %>%
  transmute(ISOLATE, iso_cluster, cell_death_level = if_else(iso_rank == "iso2", "Low", "High"))

# Add some metadata
df_cell_death_close_clusters_long_with_metadata <- df_cell_death_close_clusters_long %>%
  left_join(df_genetic_pairs_unique)

# List of unique isolates
cell_death_close_clusters_no_redundancy <- sort(unique(df_cell_death_close_clusters_long$ISOLATE))
write_lines(cell_death_close_clusters_no_redundancy, "Ideas_Grant_2020_analysis/Genetic_pairs_table/cell_death_close_clusters_no_redunancy.txt")
```

## Import tree

```{r}
cell_death_tree <- read.tree("Ideas_Grant_2020_analysis/Raw_data/cell_death_close_clusters_no_redunancy.tree") %>%
  phytools::midpoint.root() %>%
  drop.tip("Reference")
p <- ggtree(cell_death_tree, layout = "circular")
p

```

## Annotate tree with mortality and convergent genes

```{r}
metadata_matrix <- df_cell_death_close_clusters_long_with_metadata %>%
  select(ISOLATE, CC, cell_death_level) %>%
  distinct() %>%
  column_to_rownames("ISOLATE")
p2 <- gheatmap(p, metadata_matrix %>% select(cell_death_level), width = .1, offset = .1, colnames = F) +
  scale_fill_manual(values = c("navy", "orange"), name = "Cell death level", guide = guide_legend(order = 1)) 
p2

library(ggnewscale)
# p3 <- p2 + new_scale_fill()

# p4 <- gheatmap(p3, metadata_matrix %>%
#            select(CC), offset = .2) +
#   scale_fill_viridis_d()
# p4

top_genes <- df_convergence_cell_death_clusters %>%
  ungroup() %>%
  arrange(desc(n_clusters), desc(n_st), desc(n_positions)) %>%
  ungroup() %>% distinct(clstr_prot) %>% filter(row_number() <= 5)

df_top_genes <- df_convergence_cell_death_clusters %>%
  ungroup() %>%
  filter(clstr_prot %in% top_genes$clstr_prot) %>%
  distinct(n_clusters, ISOLATE, clstr_prot, GENE, PRODUCT, neb_mutant_id, neb_gene, neb_product, MUTATION_SHORT) %>%
  group_by(clstr_prot) %>%
  mutate(gene_length = if_else(!is.na(GENE),
                              str_length(GENE), 
                              NA_integer_)) %>%
  mutate(min_gene_length = if_else(!is.na(GENE),
                              min(str_length(GENE)), 
                              NA_integer_)) %>%
  arrange(min_gene_length) %>%
  mutate(gene_label = GENE[1]) %>%
  mutate(gene_label = if_else(is.na(gene_label),
                              str_c("HP-", clstr_prot),
                              gene_label)) %>%
  group_by(gene_label, ISOLATE) %>%
  mutate(allele = str_c(MUTATION_SHORT, collapse = " ")) %>%
  mutate(gene_mutation = str_c(gene_label, allele, sep = " ")) %>%
  arrange(desc(n_clusters), !is.na(gene_label))

df_top_genes <- df_top_genes %>%
  ungroup() %>%
  distinct(label = ISOLATE, gene_label, allele)

top_genes_matrix <- df_top_genes %>%
  pivot_wider(names_from = gene_label, values_from = allele) %>%
  column_to_rownames("label")
```


```{r}
matrix <- top_genes_matrix[,1:5]
p <- p2
for (i in 1:length(colnames(matrix))){
  
  m <- top_genes_matrix[,i, drop = F]
  
  p <- p + new_scale_fill()
  
  p <- gheatmap(p, m, offset = .3 + .075*(i-1), width = .1, colnames = F, color = "grey") +
  scale_fill_brewer(palette = pal[i], na.translate = F, name = colnames(matrix)[i], guide = guide_legend(order = i+1, direction = "horizontal", nrow = 1, title.position = "top"),
                    labels = NULL)

}
p +
  theme(legend.spacing.x = unit(0, "cm"),
        legend.title = element_text(face = "bold", size = 18),
        legend.text = element_text(size = 16))
ggsave("Ideas_Grant_2020_analysis/figures/cell_death_clusters_no_redundancy_tree.pdf")
```

