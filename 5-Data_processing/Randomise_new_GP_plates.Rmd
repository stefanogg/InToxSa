---
title: "Randomise plates for repeat pairs"
author: "Stefano Giulieri"
date: "22/02/2021"
output: html_document
---

Here we randomise a new set of plates: they will include all genetic pairs with significant PI changes (as selected by Romain).

Some questions to clarify:

* keep pairs on the same plate?
* confirm controls and their position


```{r setup}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here::here())
msg <- glue::glue("My directory is {here::here()}")
message(msg)
```


```{r message=F}
library(tidyverse)
library(tidygraph)
library(ggraph)
rm(list = ls())

source("Functions/all_functions.R")
```

# List of strains

```{r}
significant_pairs_PI <- read_csv("Genetic_pairs_analysis_Oct_2020/processed_data/monophyletic_clusters/genetic_pairs_significant_PI_change.csv") %>%
  mutate(phenotype = "PI") 
glimpse(significant_pairs_PI)
significant_pairs_GC <- read_csv("Genetic_pairs_analysis_Oct_2020/processed_data/monophyletic_clusters/genetic_pairs_significant_GC_change.csv") %>%
  mutate(non_directional_pair_id = str_c(iso1, iso2, sep = "-"),
         phenotype = "GC")
glimpse(significant_pairs_GC)

# intersection between the two datasets?
intersect_strains <- intersect(c(significant_pairs_PI$iso1, significant_pairs_PI$iso2),
          c(significant_pairs_GC$iso1, significant_pairs_GC$iso2)) %>%
  sort()
length(intersect_strains)

intersect_pairs <- intersect(significant_pairs_PI$non_directional_pair_id,
                             significant_pairs_GC$non_directional_pair_id) %>%
  sort()
length(intersect_pairs)

# union
union_strains <- union(c(significant_pairs_PI$iso1, significant_pairs_PI$iso2),
          c(significant_pairs_GC$iso1, significant_pairs_GC$iso2)) %>%
  sort()
length(union_strains)

union_pairs <- union(significant_pairs_PI$non_directional_pair_id,
                             significant_pairs_GC$non_directional_pair_id) %>%
  sort()
length(union_pairs)

significant_pairs <- significant_pairs_PI %>%
  full_join(significant_pairs_GC) %>%
  group_by(non_directional_pair_id, iso1, iso2) %>%
  summarise(phenotype = str_c(phenotype, 
                              collapse = " & "))
```

We have 92 unique strains for 51 pairs (union of the two datasets). Fourteen strains are shared but only two pairs are both PI and GC. 

Graph representation. We use `tidygraph::centrality_betwenness()` to highlight nodes (strains) with more than one connection (= strains in more than one contrasting pair)

```{r}
pairs_net <- as_tbl_graph(significant_pairs %>% ungroup %>% select(from = iso1, to = iso2, phenotype, non_directional_pair_id ))

pairs_net 

ggraph(pairs_net, layout = "nicely") +
  geom_edge_link(aes(colour = phenotype), edge_width = 2, arrow = arrow(length = unit(5, 'mm'))) +
  geom_node_point(aes(size = centrality_betweenness(directed = F)),
                  colour = "black") +
  geom_node_text(aes(label = name, alpha = centrality_betweenness(directed = F)), repel = T, size = 4) +
  scale_alpha_continuous(guide = F) +
  scale_size_continuous(name = "Centrality (~number of connections)") +
  scale_edge_color_manual(values = c("#fdae61", "#abd9e9", "black")) +
  theme_graph()



```

We now use `tidygraph::group_components()` to group nodes (strains) and edges (pairs) according to whether they are connected or not. This will allow us to create groups of connected strains that will have to be on the same plate.

```{r fig.width=12, fig.height=12}
pairs_net %>%
  activate(nodes) %>%
  mutate(g = group_components()) %>%
  ggraph(layout = "nicely") +
  geom_edge_link(aes(colour = phenotype), edge_width = 2) +
  geom_node_point(aes(size = centrality_betweenness(directed = F))) +
  geom_node_text(aes(label = name, alpha = centrality_betweenness(directed = F)), repel = T, size = 4) +
  facet_nodes(~as.factor(g), scales = "free") +
  scale_alpha_continuous(guide = F) +
  scale_edge_color_manual(values = c("#fdae61", "#abd9e9", "black")) +
  labs(title = "Contrasting pairs divided in 42 independent groups of connected strains",
       subtitle = "Groups 1-6 have more than 2 strains (more than one pair)") +
  theme_graph()


df_graph_groups <- pairs_net %>%
  activate(nodes) %>%
  mutate(g = group_components()) %>%
  as_tibble() %>%
  arrange(g)
glimpse(df_graph_groups)
```

Transform into long format and assign to plate GP8, GP9, GP10. We should try to keep strains belonging to the same group (not just pairs) on the same plate. To this purpose we use the `df_graph_groups` dataframe.

```{r}
controls <- c("JE2", "TOX-4", "Non infected")
n_replicates_controls <- c(3,3,3) 
n_isolates_plate <- (96 - sum(n_replicates_controls))/3

df <- df_graph_groups %>%
  transmute(sample_id = name,
         pair_id = as.factor(g)) %>%
  arrange(pair_id) 

plates_vector <- c() # empty vector with plate numbers. 
# The for loop will generate three variables
# x (plate number), j (number of strains on the plate including the current one), 
# k (number of strains on the plate if all samples from the same patient are added)
x <- 1
j <- 1
for (i in 1:nrow(df)){
  if (i > 1){ # need to start from the second row to avoid NA
    episode <- df$pair_id[i]
    previous <- df$pair_id[i -1]
   
    if (episode != previous ){ # compute k only for the first strain if multiple strains per episode
      n_isolates_episode <- length(which(df$pair_id == df$pair_id[i]))
      k <- j + n_isolates_episode - 1 # substract 1 because first isolates already included in j
      # if the number of strains (including expected multiple same-patient isolates) exceeds the maximum number, start a new plate
      if (j > n_isolates_plate | k > n_isolates_plate){
        j <- 1
        x <- x + 1
      }
    } else {
    if (j > n_isolates_plate){
      j <- 1
      x <- x + 1
    }
  }
  }
  plates_vector[i] <- x
  j <- j + 1
}
df_strains_plate <- df %>%
  mutate(plate = plates_vector) %>%
  mutate(plate = str_c("GP", plate + 7))
glimpse(df_strains_plate)

# Quick check that the same-pair strains are on the same plate
df_strains_plate %>%
  ggplot(aes(x = fct_rev(pair_id), 
             y = fct_relevel(plate, c("GP8", "GP9")))) +
  geom_tile(fill = "navy") +
  coord_flip() +
  labs(x = "", y = "") +
  theme_bw()

rm(df, significant_pairs)
rm(i, j, k, n_isolates_plate, plates_vector, previous)
```

We remove strain BPH3547 is missing. We leave BPH3545 to be sure we don't alter the plate plan too much

```{r}
df_strains_plate <- df_strains_plate %>%
  filter(sample_id != "BPH3547")
```


Export file with plate attribution of the strains.

```{r}
dir <- "plate_info/plate_assignment/"
dir.create(dir)

df_strains_plate %>%
  write_csv(str_c(dir, "plate_assignment_GP8_GP11.csv"))

df_strains_plate %>%
  filter(plate != "GP11") %>%
  write_csv(str_c(dir, "plate_assignment_GP8_GP10.csv"))
```


Now we can plan plates GP8-GP10

```{r}
dir <- "plate_info/well_info/"
dir.create(dir)

well_info <- lapply(unique(df_strains_plate$plate %>% str_subset("GP11", negate = T)), function(x){
  df <- df_strains_plate %>%
    filter(plate == x)
  well_info <- plate_planner(
    isolates = df$sample_id,
  randomise = TRUE,
  fixed = NULL,
  controls = controls,
  n_replicates_controls = n_replicates_controls
) %>%
    mutate(plate_number = x)
  
  write_csv(well_info,
            str_c(dir, "well_info_plate", x, ".csv"))
  
  return(well_info)
}) %>%
  bind_rows()

well_info_2 <- plate_planner(
  isolates = df_strains_plate %>% filter(plate == "GP11") %>% pull(sample_id),
  controls = controls,
  randomise = T,
  fixed = NULL,
  exclude_outer_wells = 2,
  n_replicates_controls = n_replicates_controls
) %>%
  mutate(plate_number = "GP11")

write_csv(well_info_2,
            str_c(dir, "well_info_plateGP11.csv"))

well_info <- well_info %>%
  bind_rows(well_info_2)


```

And map them on the 96-well plate

```{r}
dir <- "plate_info/plate_maps/"

plate_info <- lapply(unique(df_strains_plate$plate), function(x){
  df <- well_info %>%
    filter(plate_number == x)
  plate_info <- plate_mapper(df)
  return(plate_info)
})
names(plate_info) <- str_c(
  "plate_", 
  unique(df_strains_plate$plate))
for (i in plate_info) print(knitr::kable(i, format = "pipe"))

purrr::walk(names(plate_info), function(x){
  df <- plate_info[[x]]
  file <- str_c(
    dir, "/",
    x,
    ".csv"
  )
  write_csv(df, file)
})
```

