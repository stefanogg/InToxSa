---
title: "Compile table of genetic_pairs and mutation lists"
author: "Stefano Giulieri"
date: "16/12/2020"
output: html_document
---

This script focuses on the first part of the analysis of genetic pairs: defining symmetric and non-symmetric pairs based on the genetic distance and compile two lists of mutations within the pairs (i.e. iso2 mutations when using iso1 as internal reference):
1. Mapping on the de novo assembly of the internal reference (iso1)
2. Mapping on BPH2947 (internal ST239 reference genome)

# Set/check knitR option and working directory

```{r setup, include=T}
library(tidyverse)
library(ggpubr)
library(harrietr)
library(here)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here())
setwd(here())
print(paste("My working directory is:" ,here()))
rm(list = ls())
```

# Part 1: define genetic pairs

## Raw data: existing list of genetic pairs

### "Naked" list 

This simple table has three columns: unique pair_id, iso1, iso2. It includes 2,484 pairs. Pairs are symmetric (A <-> B and B <-> A) and the pair id designate a unique pairs, i.e. A <-> B and B <-> A have different id.

Importantly, this table was used to run snippy and call variants within each pair, where iso1 was used as internal reference.

```{r}
dir <- "Genetic_pairs_analysis_Oct_2020/raw_data/pairs_metadata/"
dir.create(dir)

f <- "Ideas_Grant_2020_analysis/Genetic_pairs_table/genetic_pairs.tab"
fname <- basename(f)
file.copy(f, dir)

genetic_pairs <- read_tsv(str_c(dir, fname), col_names = c("PAIR_ID", "iso1", "iso2"))
```

### RG alternative pair id

```{r}
f <- "Genetic_pairs_analysis_Oct_2020/metadata/genetic_pairs_id_metadata.Rda"
fname <- basename(f)
file.copy(f, dir)

genetic_id_pairs_metadata <- readRDS(str_c(dir, fname))
```

### Merge the information 

```{r}
genetic_pairs_metadata <- genetic_pairs %>%
  left_join(genetic_id_pairs_metadata) %>%
  rename(non_directional_pair_id = pair_id)

# remove the other dataframes
rm(genetic_pairs, genetic_id_pairs_metadata)
```

# Part 2: import snippy output

## Mapping on the de novo assembly of the internal reference

```{r}
dir <- "Genetic_pairs_analysis_Oct_2020/raw_data/snippy/denovo/"
dir.create(dir)
f <- "~/Documents/Transfer_with_server/all_pair_id_snps.mask.tab"
fname <- basename(f)
file.copy(f, str_c(dir, fname), overwrite = T)



snippy_denovo <- read_tsv(str_c(dir, fname)) %>%
  arrange(PAIR_ID) 
glimpse(snippy_denovo)

# modify snippy output: 
# 1) generate iso1 and iso2 for merging with the phenotypic analysis
# 2) modify CHROM (contig name) to be consistent with the labelling in bed files down the track
# 3) extract mutation effects for easier interpretation


source("Functions/all_functions.R")
snippy_denovo_modified <- snippy_denovo %>%
  mutate(iso1 = str_remove(REFERENCE, ".gbk"),
         iso2 = ISOLATE,
         CHROM = str_c(iso1, "_", CHROM)) %>%
  separate(EFFECT, 
           into = c("EFFTYPE", "NUCLEOTIDE_CHANGE", "MUTATION"), 
           sep = "\\s", 
           remove = T, 
           extra = "merge") %>%
  mutate(NUCLEOTIDE_CHANGE = str_remove(NUCLEOTIDE_CHANGE, "c."),
         MUTATION = str_remove(MUTATION, "p."),
         MUTATION_SHORT = aa_convert(MUTATION)) %>%
  separate(AA_POS, 
           into = c("AA_POS", "AA_LENGTH"), 
           sep = "/", 
           remove = T) %>%
  mutate_at(vars(starts_with("AA")), 
            as.numeric)
glimpse(snippy_denovo_modified)

snippy_denovo_modified %>%
  .$ISOLATE %>%
  n_distinct()

rm(snippy_denovo)
```


## Explore number of mutations

This table was generated on the server using the command

` for i in GP*; do n=$(wc -l $i/all_pair_id_snps.mask.tab | cut -f1 -d ' '); echo -e "$i\t$n"; done | awk -v OFS='\t' '{print $1,$2-1}' > mutation_counts.tab`


This should give us reassurance that 0 mutations are not data manipulation errors

```{r}
f <- "~/Documents/Transfer_with_server/denovo_mutation_counts.tab"
fname <- basename(f)
file.copy(f, dir, overwrite = T)

df_denovo_mutation_counts <- read_tsv(str_c(dir, fname), col_names = c("PAIR_ID", "n_mutations"))

df_denovo_mutation_counts %>%
  ggplot(aes(x = n_mutations)) +
  geom_histogram(binwidth = 10) +
  geom_density(aes(y = 10* ..count..)) +
  theme_bw()


# Genetic distance filter threshold:
# - n mutation <= 100 indel or SNP as determined by snippy pairwise mapping 

distant_pairs <- df_denovo_mutation_counts %>%
  filter(n_mutations > 100) %>%
  .$PAIR_ID
df_denovo_mutation_counts %>%
  filter(!PAIR_ID %in% distant_pairs) %>%
  ggplot(aes(x = n_mutations)) +
  geom_histogram(binwidth = 5) +
  geom_density(aes(y = 5* ..count..)) +
  theme_bw()

# Alternative approach: outliers detection based on statistics, eg tukey method

df_denovo_mutation_counts <- df_denovo_mutation_counts %>%
  ungroup() %>%
  mutate(is_outlier_tukey = is_out_tukey(n_mutations),
         is_outlier_mad = is_out_mad(n_mutations),
         is_outlier_sd = is_out_sd(n_mutations))

# It looks like the tukey method is the most conservative approach. Suggest to keep the manually fixed threshold of 100 to be consistent with the Ideas grant analysis


```

### Check filtering: was it symmetric?

```{r}
df_check <- df_denovo_mutation_counts %>%
  left_join(genetic_pairs_metadata %>% select(PAIR_ID, iso1, iso2, non_directional_pair_id)) %>% 
  mutate(excluded = !PAIR_ID %in% distant_pairs) %>%
  group_by(non_directional_pair_id) %>%
  mutate(n_excluded = sum(excluded)) %>%
  filter(n_excluded == 1)

df_check %>%
  group_by(non_directional_pair_id) %>%
  mutate(min = min(n_mutations),
         max = max(n_mutations)) %>%
  ggplot(aes(x = fct_reorder(non_directional_pair_id, max))) +
  geom_linerange(aes(ymin = min, ymax =max)) +
  coord_flip()

df_check %>%
  group_by(non_directional_pair_id) %>%
  mutate(min = min(n_mutations),
         max = max(n_mutations)) %>%
  ggplot(aes(x = max)) +
 geom_histogram(binwidth = 5) +
  geom_density(aes(y = 5* ..count..)) +
  theme_bw()

df_check %>%
  group_by(non_directional_pair_id) %>%
  mutate(min = min(n_mutations),
         max = max(n_mutations)) %>%
  ungroup() %>%
  mutate(is_outlier = is_out_tukey(max)) %>%
  ggplot(aes(x = max, fill = is_outlier)) +
 geom_histogram(binwidth = 5) +
  # geom_density(aes(y = 5* ..count..)) +
  theme_bw()
  
```

We have 388 symmetric pairs (194 unique pairs), where one of the two pairs was excluded based on the threshold and the other was kept.
The maximum number of mutations in the excluded pair is 254, with some pairs showing a wide difference between the symmetric pairs.

Suggest keeping both pairs for now to increase sensitivity, with the exception of those with maximum n_mutations > 150. However, we need to investigate the reasons for the (sometimes) wide discrepancies. 

No need to filter now, we keep all pairs and assess filtering later.

```{r}
distant_pairs <- df_denovo_mutation_counts %>%
  left_join(genetic_pairs_metadata %>% select(PAIR_ID, iso1, iso2, non_directional_pair_id)) %>%  
  group_by(non_directional_pair_id) %>%
  filter(any(n_mutations > 150)) %>%
  .$PAIR_ID

length(distant_pairs)
rm(distant_pairs)
```


### clustering of protein genes (cd-hit)

cd-hit was first run on the amino acid sequences of the mutated genes

cd-hit was run using default parameters

id threshold (`-C`) 0.9, this is defined as number identical amino acids or bases in alignment divided by the full length of the shorter sequence
the alignment coverage controls (-aL, -AL, -aS, -AS) defaults are 0

```{r}
f <- "~/Documents/Transfer_with_server/mutated_proteins.cd-hit.tab"
fname <- basename(f)
file.copy(f, str_c(dir, fname))

protein_clusters_data <- read_tsv(str_c(dir, fname)) %>%
  group_by(clstr) %>%
  mutate(clstr_rep_id = id[which(clstr_rep == 1)]) %>%
  select(LOCUS_TAG = id, clstr, clstr_size, length, clstr_iden, clstr_cov, clstr_rep_id)

f <- "~/Documents/Transfer_with_server/mutated_proteins.cd-hit.representative.tab"
fname <- basename(f)
file.copy(f, str_c(dir, fname))

protein_seq_data <- read_tsv(str_c(dir, fname), col_names = c("clstr_rep_id", "clstr_seq"))
```

Join to snippy output

```{r}
snippy_denovo_modified_proteins <- snippy_denovo_modified %>%
  left_join(protein_clusters_data) %>%
  left_join(protein_seq_data)
```

# Add FPR3757 annotation

We have used both cd-hit and blastp
We select the blastp annotation

```{r}
f <- "~/Documents/Transfer_with_server/mutated_genes_cdhit_FPR3757_blastp.tab"
fname <- basename(f)
file.copy(f, dir)

blastp_data <- read_tsv(str_c(dir, fname),
                        col_names = c("QUERY", "SUBJECT", "PIDENT", "ALIGNLEN", "MISMATCH", "GAPS", "QSTART", "QEND", "SSTART", "SEND", "EVALUE", "BITSCORE", "QLEN"))

df_blastp <- blastp_data %>%
  mutate(PCOV = ALIGNLEN/QLEN*100) # we need to calculate the coverge here because the qcov* variables in blastp don't represent coverage as calculated here (checked manually looking at local alignments)

df_blastp %>%
  ggplot(aes(x = PCOV)) +
  geom_histogram() +
  theme_bw()

df_blastp %>%
  ggplot(aes(x = PIDENT)) +
  geom_histogram() +
  theme_bw()

df_blastp <- df_blastp %>%
  filter(PIDENT >=90 & PCOV >= 50) %>%
  arrange(QUERY, desc(PIDENT, PCOV)) %>%
  group_by(QUERY) %>%
  slice_head(n = 1) %>%
  select(clstr_rep_id = QUERY, neb_locus_tag = SUBJECT, sequence_length = QLEN, PIDENT, PCOV)

rm(blastp_data)


snippy_denovo_modified_proteins <- snippy_denovo_modified_proteins %>%
  left_join(df_blastp)

```

Add  NEB mutants id

```{r}
df_neb <- read_csv("Ideas_Grant_2020_analysis/Raw_data/nebraska_all_proteins.csv")

snippy_denovo_modified_proteins <- snippy_denovo_modified_proteins %>%
  left_join(df_neb, by = c("neb_locus_tag" = "nebraska_locus_tag"))
```

Add aureowiki

```{r}
df_aureowiki <- read_csv("Ideas_Grant_2020_analysis/Genetic_pairs_analysis_completed/Raw_data/aureowiki_USA300_FPR3757.csv", guess_max = 3000) 
glimpse(df_aureowiki)
# Fix problematic names and reduce number of variables (for now)
df_aureowiki <- df_aureowiki %>%
  select(neb_locus_tag = `locus tag`,
         neb_locus_tag2 = `new locus tag`,
         pan_gene_symbol = `pan gene symbol`,
         pan_locus_tag = `pan locus tag`,
         neb_product = product,
         neb_gene = symbol,
         neb_strand = strand,
         neb_start = start,
         neb_end = end,
         neb_gene_length = `gene length`,
         MicrobesOnline, BioCyc,
         neb_operon = operon
         )

snippy_denovo_modified_proteins <- snippy_denovo_modified_proteins %>%
  left_join(df_aureowiki)

```

RG comment: not 100% sure how exactly all protein_id have been matched together but we probably need to discuss this to make sure everything is done as carefully as possible. In my experience error/loss of matching at each step could lead to spurious results or missing some genes etc...

I am wondering if we the current cd-hit approach we would miss frameshift/truncating mutation that in Nterm of prot as short residual prot would not be annotated by prokka or not clustered by cd-hit. We don't want to miss those!
For this reason we should probably align reads to all pan genes representative individually? 

May be using a pangenome tool would be the best way here to provide each individual genome a gene_id that match a unique pangenome_gene_id. I used PIRATE to generate this for the BPA sepsis data but not ideal (Surprinsingly, I couldn't find a single pangenome tool that provide a pangenome_gene_id to every gene_id in an easy parsable format... To me it is the primary/1st role of pangenome tool). 

Ideally, we should do this including all useful genomes (all VANANZ, JE2/FPR3757 annot, aureowiki representative genome to match with all their genomes and pangenome_id, NRS384, BPH model strain of the lab (BPA sepsis strain (annotated PACBIO reference publicly available)). 

Even more ideally :) we also would like to use a tool that allow to work with custom multifasta for annotation to get pangenome_id for sRNA, intergenic region, promoter, SSR... 

SSR would be tricky and probably need to be annotated individually for each reference using kmer-ssr without providing pangenome_id (without genome to genome universal matching). But the other can be matched based on cd-hit or blast alignment.

May be the best/easier way would be to complile multifasta(s) (with all CDS, all prom, all_intergenic?, all sRNA, all TSS) and cd-hit as you did. 

#### merge clusters and sequences with snippy data

```{r}
snippy_denovo_modified_proteins <- snippy_denovo_modified %>%
  left_join(protein_clusters_data,
            by = c("LOCUS_TAG" = "id_prot")) %>%
  left_join(protein_seq_data,
            by = c("LOCUS_TAG" = "FASTA_ID_prot"))
snippy_denovo_modified_proteins
```

### clustering and annotation of intergenic regions 

For now we don't look at intergenic regions. This will need to be performed later.

## Mapping on BPH2947

```{r}
f <- "Genetic_pairs_analysis_Oct_2020/raw_data/snippy/all_snippy_BPH2947_pairwise.tab"
snippy_BPH2947 <- read_tsv(f)
```

### Modify snippy output

```{r}
# modify snippy output: 
# 1) generate iso1 and iso2 for merging with the phenotypic analysis
# 2) modify CHROM (contig name) to be consistent with the labelling in bed files down the track
# 3) extract mutation effects for easier interpretation

snippy_BPH2947_modified <- snippy_BPH2947 %>%
  mutate(iso1 = INTERNAL_REF,
         iso2 = ISOLATE,
         CHROM = str_c(iso1, "_", CHROM)) %>%
  separate(EFFECT, 
           into = c("EFFTYPE", "NUCLEOTIDE_CHANGE", "MUTATION"), 
           sep = "\\s", 
           remove = T, 
           extra = "merge") %>%
  mutate(NUCLEOTIDE_CHANGE = str_remove(NUCLEOTIDE_CHANGE, "c."),
         MUTATION = str_remove(MUTATION, "p."),
         MUTATION_SHORT = aa_convert(MUTATION)) %>%
  separate(AA_POS, 
           into = c("AA_POS", "AA_LENGTH"), 
           sep = "/", 
           remove = T) %>%
  mutate_at(vars(starts_with("AA")), 
            as.numeric)
snippy_BPH2947_modified

snippy_BPH2947_modified %>%
  .$ISOLATE %>%
  n_distinct()

```

### Add FPR3757 annotation

We have used both cd-hit and blastp
We select the blastp annotation

```{r}
dir <- "Genetic_pairs_analysis_Oct_2020/raw_data/snippy/"
f <- "~/Documents/Transfer_with_server/Sa_BPH2947_FPR3757_blastp.tab"
fname <- basename(f)

file.copy(f, dir)

blastp_data <- read_tsv(str_c(dir, fname),
                        col_names = c("QUERY", "SUBJECT", "PIDENT", "ALIGNLEN", "MISMATCH", "GAPS", "QSTART", "QEND", "SSTART", "SEND", "EVALUE", "BITSCORE", "QLEN"))

df_blastp <- blastp_data %>%
  mutate(PCOV = ALIGNLEN/QLEN*100) # we need to calculate the coverge here because the qcov* variables in blastp don't represent coverage as calculated here (checked manually looking at local alignments)

df_blastp %>%
  ggplot(aes(x = PCOV)) +
  geom_histogram() +
  theme_bw()

df_blastp %>%
  ggplot(aes(x = PIDENT)) +
  geom_histogram() +
  theme_bw()

df_blastp <- df_blastp %>%
  filter(PIDENT >=90 & PCOV >= 50) %>%
  arrange(QUERY, desc(PIDENT, PCOV)) %>%
  group_by(QUERY) %>%
  slice_head(n = 1) %>%
  select(LOCUS_TAG = QUERY, neb_locus_tag = SUBJECT, sequence_length = QLEN, PIDENT, PCOV)

rm(blastp_data)


snippy_BPH2947_modified_proteins <- snippy_BPH2947_modified %>%
  left_join(df_blastp)

```

Add  NEB mutants id

```{r}


snippy_BPH2947_modified_proteins <- snippy_BPH2947_modified_proteins %>%
  left_join(df_neb, by = c("neb_locus_tag" = "nebraska_locus_tag"))
```

Add aureowiki

```{r}


snippy_BPH2947_modified_proteins <- snippy_BPH2947_modified_proteins %>%
  left_join(df_aureowiki)
```


### Explore number of mutations

This table was generated on the server using the command

` for i in GP*; do n=$(wc -l $i/all_pair_id_snps.mask.tab | cut -f1 -d ' '); echo -e "$i\t$n"; done | awk -v OFS='\t' '{print $1,$2-1}' > mutation_counts.tab`

```{r}
f <- "~/Documents/Transfer_with_server/BPH2947_mutation_counts.tab"
fname <- basename(f)
file.copy(f, dir)

df_BPH2947_mutation_counts <- read_tsv(str_c(dir, fname), col_names = c("PAIR_ID", "n_mutations"))

df_BPH2947_mutation_counts %>%
  ggplot(aes(x = n_mutations)) +
  geom_histogram(binwidth = 20) +
  geom_density(aes(y = 20* ..count..)) +
  theme_bw()
```

We know that mapping on a distant reference gives a less accurate estimate of the number of mutations. Here, we use BPH2947 mapping just for consistency of annotation, not for the primary analysis. Therefore, we could use the `distant_pairs` vector from the de novo assembly mapping to mask distant pairs. Again, this filtering will be performed later

```{r}
df_BPH2947_mutation_counts %>%
  ggplot(aes(x = n_mutations)) +
  geom_histogram(binwidth = 20) +
  geom_density(aes(y = 20* ..count..)) +
  facet_wrap(~PAIR_ID %in% distant_pairs, scales = "free_x") +
  theme_bw()
```

We can see that distant pairs based on mapping on the denovo assembly are not the same pairs that have high number of mutations based on mapping on the single reference!

# Background recurrent mutations in all pairs (at gene level)

These data can be used for enrichment analysis later on.

## Snippy BPH2947

```{r}
df_backround_recurrent_BPH2947 <- snippy_BPH2947_modified_proteins %>%
  drop_na(LOCUS_TAG) %>%
  mutate(synonymous_mutation = EFFTYPE == "synonymous variant") %>%
  group_by(LOCUS_TAG, GENE, PRODUCT, nebraska_locus_tag, neb_mutant_id, neb_product, synonymous_mutation) %>%
  summarise(n_mutated = n_distinct(PAIR_ID))

df_backround_recurrent_BPH2947 %>%
  ggplot(aes(x = n_mutated)) +
  geom_histogram(binwidth = 20) +
  geom_density(aes(y = 20* ..count..)) +
  theme_bw()
```

## Snippy denovo

```{r}
df_backround_recurrent_denovo <- snippy_denovo_modified_proteins %>%
  drop_na(clstr_prot) %>%
  mutate(synonymous_mutation = EFFTYPE == "synonymous variant") %>%
  group_by(clstr_prot, nebraska_locus_tag, neb_mutant_id, neb_product, synonymous_mutation) %>%
  summarise(n_mutated = n_distinct(PAIR_ID))

df_backround_recurrent_denovo %>%
  ggplot(aes(x = n_mutated)) +
  geom_histogram(binwidth = 20) +
  geom_density(aes(y = 20* ..count..)) +
  theme_bw()
```

# Export processed data

# Create a unique dataframe with mutations counts and metadata

```{r}
df_genetic_pairs_mutcounts_metadata <- genetic_pairs_metadata %>%
  left_join(df_denovo_mutation_counts %>% select(PAIR_ID, n_mutations_denovo = n_mutations)) %>%
  left_join(df_BPH2947_mutation_counts %>% select(PAIR_ID, n_mutations_BPH2947 = n_mutations))
```


```{r}
dir <- "Genetic_pairs_analysis_Oct_2020/processed_data/snippy/"
dir.create(dir)

df_genetic_pairs_mutcounts_metadata %>%
  saveRDS(str_c(dir, "df_genetic_pairs_mutcounts_metadata.Rda"))

# snippy denovo
subdir <- str_c(dir, "denovo/")
dir.create(subdir)
snippy_denovo_modified_proteins %>%
  saveRDS(str_c(subdir, "snippy_denovo_mutations.Rda"))
df_denovo_mutation_counts %>%
  saveRDS(str_c(subdir, "snippy_denovo_mutcounts.Rda"))
df_backround_recurrent_denovo %>%
  saveRDS(str_c(subdir, "snippy_denovo_recurrent_counts.Rda"))

# snippy BPH2947
subdir <- str_c(dir, "BPH2947/")
dir.create(subdir)
snippy_BPH2947_modified %>%
  saveRDS(str_c(subdir, "snippy_BPH2947_mutations.Rda"))
snippy_BPH2947_modified_proteins %>%
  saveRDS(str_c(subdir, "snippy_BPH2947_mutations_annotated_with_FPR3757.Rda"))
df_BPH2947_mutation_counts %>%
  saveRDS(str_c(subdir, "snippy_BPH2947_mutcounts.Rda"))
df_backround_recurrent_BPH2947 %>%
  saveRDS(str_c(subdir, "snippy_BPH2947_recurrent_counts.Rda"))

```

